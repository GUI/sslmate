#!/usr/bin/env perl

#
# Copyright (c) 2014-2015 Opsmate, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name(s) of the above copyright
# holders shall not be used in advertising or otherwise to promote the
# sale, use or other dealings in this Software without prior written
# authorization.
#

#
# This program is designed to be used with the online SSLMate service at
# <https://sslmate.com/>.  Use of the SSLMate service is governed by the
# Terms and Conditions available online at <https://sslmate.com/terms>.
#

use 5.010;	# 5.10
use strict;
use warnings;
use Getopt::Long;
use Errno;
use Fcntl;
use POSIX qw(:sys_wait_h strftime);
use Cwd qw(realpath);
use Digest::SHA qw(sha256_hex);
use File::Basename;
use File::Temp;
use IO::Handle;
use IPC::Open2;
use List::Util qw(max sum);

				# Debian/Ubuntu package		RHEL/CentOS package
				# --------------------------------------------------
# WWW::Curl::Easy		# libwww-curl-perl		perl-WWW-Curl
use URI::Escape;		# liburi-perl			perl-URI
use JSON::PP; # core in 5.13.9+	# libjson-perl			perl-JSON
use Term::ReadKey;		# libterm-readkey-perl		perl-TermReadKey

our $has_curl = eval { require WWW::Curl::Easy; 1 };

use version; our $VERSION = version->declare('0.6.2');
our $API_ENDPOINT = 'https://sslmate.com/api/v2';

our $quiet = 0;
our $config_profile;
our %global_config;
our %personal_config;
our %ephemeral_config;
our $curl;

sub print_usage {
	my ($out) = @_;

	#          |--------------------------------------------------------------------------------| 80 chars
	print $out "Usage: sslmate [OPTIONS] COMMAND [ARGS]\n";
	print $out "\n";
	print $out "Commands:\n";
	print $out " sslmate buy HOSTNAME             Buy a certificate for the given hostname\n";
	print $out " sslmate renew HOSTNAME           Renew the certificate for the given hostname\n";
	print $out " sslmate reissue HOSTNAME         Reissue the certificate for given hostname\n";
	print $out " sslmate revoke [-a] HOSTNAME     Revoke the certificate for given hostname\n";
	print $out " sslmate download HOSTNAME        Download the certificate for given hostname\n";
	#print $out " sslmate import KEYFILE CERTFILE  Import this certificate to your account\n";
	print $out " sslmate list                     List certificates in your SSLMate account\n";
	print $out " sslmate edit [OPTIONS] HOSTNAME  Edit certificate settings (e.g. auto-renew)\n";
	print $out " sslmate test HOSTNAME            Check if the certificate is properly installed\n";
	print $out " sslmate mkconfig TEMPLATE NAME   Generate configuration for the certificate\n";
	print $out " sslmate resend-email HOSTNAME    Resend the approval email for a pending cert\n";
	print $out " sslmate link                     Link this system with your SSLMate account\n";
	print $out " sslmate help                     Display help\n";
	print $out " sslmate version                  Print the version of SSLMate that's installed\n";
	print $out "\n";
	print $out "Valid options:\n";
	print $out " -p, --profile=NAME               Use the given configuration profile\n";
	print $out "\n";
	print $out "Run 'sslmate help COMMAND' for more information on a specific command.\n";
}

sub new_curl {
	my $curl = WWW::Curl::Easy->new;
	$curl->setopt(WWW::Curl::Easy::CURLOPT_PROTOCOLS(), 3);		# Only safe protocols (HTTP and HTTPS, not SMTP, SSH, etc.)
	$curl->setopt(WWW::Curl::Easy::CURLOPT_FOLLOWLOCATION(), 1);	# Follow redirects
	$curl->setopt(WWW::Curl::Easy::CURLOPT_MAXREDIRS(), 20);	# Allow at most 20 redirections
	$curl->setopt(WWW::Curl::Easy::CURLOPT_SSL_VERIFYPEER(), 1);	# Check certificates
	$curl->setopt(WWW::Curl::Easy::CURLOPT_SSL_VERIFYHOST(), 2);	# Check certificates (2 is not a typo)
	$curl->setopt(WWW::Curl::Easy::CURLOPT_USERAGENT(), "SSLMate/$VERSION");
	return $curl;
}

sub prompt_user {
	my ($message) = @_;

	print $message;
	my $answer = <STDIN>;
	die "Error: Input ended prematurely.\n" unless defined($answer);
	chomp $answer;
	return $answer;
}

sub prompt_yesno {
	while (defined(my $answer = prompt_user("Enter yes or no: "))) {
		if ($answer eq 'yes') {
			return 1;
		} elsif ($answer eq 'no') {
			return 0;
		} else {
			print "I did not understand that.\n";
		}
	}
}

sub prompt_password {
	my ($message) = @_;

	print $message;

	my $password = '';
	ReadMode(4);
	my %ctrl = GetControlChars;
	while (defined(my $key = ReadKey(0))) {
		if ($key eq "\n" || $key eq "\r" || $key eq $ctrl{EOF}) { # e.g. Ctrl+D
			print "\n";
			last;
		} elsif ($key eq $ctrl{INTERRUPT}) { # e.g. Ctrl+C
			$password = undef;
			last;
		} elsif ($key eq $ctrl{ERASE}) {
			if ($password ne '') {
				chop $password;
				print "\b \b";
			}
		} elsif ($key eq $ctrl{KILL} || $key eq $ctrl{ERASEWORD}) { # e.g. Ctrl+U, Ctrl+W
			while ($password ne '') {
				chop $password;
				print "\b \b";
			}
		} else {
			$password = $password . $key;
			print "*";
		}
	}
	ReadMode(0);

	return $password;
}

sub config_has {
	my ($name) = @_;

	return defined $ephemeral_config{$name} || defined $personal_config{$name} || defined $global_config{$name};
}

sub get_config {
	my ($name, $default_value) = @_;

	return $ephemeral_config{$name} if defined $ephemeral_config{$name};
	return $personal_config{$name} if defined $personal_config{$name};
	return $global_config{$name}   if defined $global_config{$name};

	return $default_value;
}

sub migrate_config_option {
	my ($config_ref, $old_name, $new_name) = @_;

	if (exists $config_ref->{$old_name}) {
		$config_ref->{$new_name} = $config_ref->{$old_name} unless exists $config_ref->{$new_name};
		delete $config_ref->{$old_name};
	}
}

sub migrate_api_creds {
	my ($config_ref) = @_;

	if (exists $config_ref->{account_id}) {
		if (exists $config_ref->{api_key} && not($config_ref->{api_key} =~ /_/)) {
			$config_ref->{api_key} = join('_', $config_ref->{account_id}, $config_ref->{api_key});
		}
		delete $config_ref->{account_id};
	}
}

sub read_config_file {
	my ($filename) = @_;

	open(my $config_fh, '<', $filename) or die "Error: Unable to open $filename for reading: $!\n";
	my %config_hash = map { my @f = split(' ', $_, 2); $f[0] => $f[1] } grep(/^[^#]/, map { chomp; $_ } <$config_fh>);
	close($config_fh);
	migrate_config_option(\%config_hash, 'api-endpoint', 'api_endpoint');
	migrate_config_option(\%config_hash, 'account-id', 'account_id');
	migrate_config_option(\%config_hash, 'api-key', 'api_key');
	migrate_api_creds(\%config_hash);
	return %config_hash;
}
sub write_config_file {
	my ($filename, $config_ref) = @_;
	
	sysopen(my $config_fh, $filename, O_WRONLY | O_TRUNC | O_CREAT, 0600) or die "Error: Unable to open $filename for writing: $!\n";
	for my $param_name (keys %$config_ref) {
		print $config_fh $param_name . ' ' . $config_ref->{$param_name} . "\n";
	}
	close($config_fh);
}
sub get_personal_config_path {
	return $ENV{'SSLMATE_CONFIG'} if $ENV{'SSLMATE_CONFIG'};
	return $ENV{'HOME'} . '/.sslmate' . ($config_profile ? "-$config_profile" : "") if $ENV{'HOME'};
	die "Error: Neither \$SSLMATE_CONFIG nor \$HOME environment variables set.\n";
}
sub get_global_config_path {
	return '/etc/sslmate' . ($config_profile ? "-$config_profile" : "") . '.conf';
}
sub load_config {
	# Personal config
	%personal_config = ();

	my $personal_config_path = get_personal_config_path;
	if (-e $personal_config_path) {
		%personal_config = read_config_file($personal_config_path);
	}

	# Global config
	%global_config = ();

	my $global_config_path = get_global_config_path;
	# global config file might be readable only by root, so only attempt
	# to access if it's readable.
	if (-r $global_config_path) {
		%global_config = read_config_file($global_config_path);
	}
}
sub save_config {
	write_config_file(get_personal_config_path, \%personal_config);
}
sub is_linked {
	return config_has('api_key');
}

sub init_default_paths {
	my ($do_mkdir) = @_;
	$do_mkdir //= 1;
	if (!config_has("key_directory") && !config_has("cert_directory")) {
		if ($> == 0) {
			my $default_directory = '/etc/sslmate' . ($config_profile ? "-$config_profile" : "");
			if ($do_mkdir && !mkdir($default_directory, 0755)) {
				die "Error: Unable to create $default_directory: $!\n" unless $!{EEXIST};
			}
			$global_config{'key_directory'} = $default_directory;
			$global_config{'cert_directory'} = $default_directory;
		}
	}
	unless (get_config('honor_umask', 'no') eq 'yes') {
		umask 0022;
	}
}

sub file_contents_are {
	my ($filename, $contents) = @_;
	open(my $fh, '<', $filename) or return 0;
	my $actual_contents = do { local $/; <$fh> };
	return $actual_contents eq $contents;
}

sub read_first_crt {
	my ($fh) = @_;
	my $crt = '';
	while (defined(my $line = <$fh>)) {
		chomp $line;
		$crt .= $line;
		$crt .= "\n";
		last if $line eq '-----END CERTIFICATE-----';
	}
	return $crt;
}

sub make_openssl_req_cnf {
	my ($dn) = @_;
	my $tempfile = File::Temp->new();
	print $tempfile <<EOF;
[ req ]
distinguished_name	= req_distinguished_name
prompt			= no
[ req_distinguished_name ]
EOF
	for my $component (qw/C ST L O OU CN/) {
		print $tempfile $component . " = " . $dn->{$component} . "\n" if defined $dn->{$component};
	}
	close $tempfile;
	return $tempfile;
}

sub get_cert_paths {
	my ($cn) = @_;

	my $key_directory = config_has("key_directory") ? get_config("key_directory") . "/" : "";
	my $cert_directory = config_has("cert_directory") ? get_config("cert_directory") . "/" : "";

	my $paths = {};
	$paths->{key_filename} = $key_directory . $cn . ".key";
	$paths->{crt_filename} = $cert_directory . $cn . ".crt";
	$paths->{chain_crt_filename} = $cert_directory . $cn . ".chain.crt";
	$paths->{chained_crt_filename} = $cert_directory . $cn . ".chained.crt";
	return $paths;
}

sub check_for_existing_files {
	my @filenames = @_;

	my $already_exists = 0;
	for my $filename (@filenames) {
		if (defined $filename && -e $filename) {
			print STDERR "Error: a file named '$filename' already exists.\n";
			$already_exists++;
		}
	}
	if ($already_exists) {
		die "Please move/remove " . ($already_exists == 1 ? "this file" : "these files") . (!config_has("key_directory") && !config_has("cert_directory") ? " or run sslmate from a different directory" : "") . ".\n";
	}
}

sub open_key_file {
	my ($filename, $overwrite) = @_;

	my $flags = O_WRONLY | O_CREAT;
	$flags |= O_EXCL unless $overwrite;

	my $fh;
	sysopen($fh, $filename, $flags, 0600)
		or die "Error: unable to open '$filename' for writing: $!\n";
	return $fh;
}

sub write_cert_files {
	my ($paths, $new_key_filename, $crt, $chain) = @_;

	# write .crt file
	my $crt_file = File::Temp->new(DIR => dirname($paths->{crt_filename}), TEMPLATE => '.sslmate.XXXXXX');
	chmod(0666 & ~umask, $crt_file);
	print $crt_file $crt;
	close $crt_file;

	# write .chain.crt file
	my $chain_crt_file = File::Temp->new(DIR => dirname($paths->{crt_filename}), TEMPLATE => '.sslmate.XXXXXX');
	chmod(0666 & ~umask, $chain_crt_file);
	print $chain_crt_file $chain;
	close $chain_crt_file;

	# write .chained.crt file
	my $chained_crt_file = File::Temp->new(DIR => dirname($paths->{crt_filename}), TEMPLATE => '.sslmate.XXXXXX');
	chmod(0666 & ~umask, $chained_crt_file);
	print $chained_crt_file $crt;
	print $chained_crt_file $chain;
	close $chained_crt_file;

	# Rename the new files on top of the old files:
	if (defined $new_key_filename && $new_key_filename ne $paths->{key_filename}) {
		rename($new_key_filename, $paths->{key_filename})
				or die "Error: " . $paths->{key_filename} . ': ' . $! . "\n";
	}

	rename($crt_file->filename, $paths->{crt_filename})
				or die "Error: " . $paths->{crt_filename} . ': ' . $! . "\n";
	$crt_file->unlink_on_destroy(0);

	rename($chain_crt_file->filename, $paths->{chain_crt_filename})
			or die "Error: " . $paths->{chain_crt_filename} . ': ' . $! . "\n";
	$chain_crt_file->unlink_on_destroy(0);

	rename($chained_crt_file->filename, $paths->{chained_crt_filename})
			or die "Error: " . $paths->{chained_crt_filename} . ': ' . $! . "\n";
	$chained_crt_file->unlink_on_destroy(0);
}

sub qs_escape {
	my ($str) = @_;
	return uri_escape_utf8($str, '^A-Za-z0-9\-\._');
}

sub native_api_call {
	my ($method, $command, $creds, $post_data) = @_;

	$curl //= new_curl;
	if ($method eq 'GET') {
		$curl->setopt(WWW::Curl::Easy::CURLOPT_HTTPGET(), 1);
	} elsif ($method eq 'POST') {
		$post_data //= '';
		$curl->setopt(WWW::Curl::Easy::CURLOPT_POSTFIELDS(), $post_data);
		$curl->setopt(WWW::Curl::Easy::CURLOPT_POSTFIELDSIZE(), length $post_data);
	}
	if ($creds) {
		$curl->setopt(WWW::Curl::Easy::CURLOPT_USERNAME(), $creds->{username});
		$curl->setopt(WWW::Curl::Easy::CURLOPT_PASSWORD(), $creds->{password});
	}
	$curl->setopt(WWW::Curl::Easy::CURLOPT_URL(), (get_config('api_endpoint') // $API_ENDPOINT) . $command);

	my $response_data = '';
	open(my $response_fh, '>', \$response_data);
	$curl->setopt(WWW::Curl::Easy::CURLOPT_WRITEDATA(), $response_fh);

	my $result = $curl->perform;
	close($response_fh);
	if ($result != 0) {
		print STDERR "Error: unable to contact SSLMate server: " . $curl->strerror($result) . "\n";
		undef $curl;
		return undef;
	}
	my $http_status = $curl->getinfo(WWW::Curl::Easy::CURLINFO_HTTP_CODE());
	my $content_type = $curl->getinfo(WWW::Curl::Easy::CURLINFO_CONTENT_TYPE());

	return ($http_status, $content_type, \$response_data);
}

sub escape_curl_param {
	my ($param) = @_;
	$param =~ s/\\/\\\\/g;
	$param =~ s/\"/\\\"/g;
	$param =~ s/\t/\\t/g;
	$param =~ s/\n/\\n/g;
	$param =~ s/\r/\\r/g;
	$param =~ s/\v/\\v/g;
	return $param;
}

sub decode_curl_error {
	my ($exit_code) = @_;

	return "Unable to resolve server address" if $exit_code == 6;
	return "Unable to connect to server" if $exit_code == 7;
	return "Timeout" if $exit_code == 28;
	return "SSL handshake failed" if $exit_code == 35;
	return "SSL certificate error" if $exit_code == 51;
	return "SSL certificate cannot be authenticated" if $exit_code == 60;

	return "curl exited with status $exit_code";
}

sub external_api_call {
	my ($method, $command, $creds, $post_data) = @_;

	local $SIG{PIPE} = 'IGNORE';

	my ($response_fh, $config_fh);
	my $curl_pid = eval { open2($response_fh, $config_fh, 'curl', '-K', '-') };
	die "Error: Unable to execute the 'curl' command - is curl installed?\n" unless defined($curl_pid);
	print $config_fh "user-agent = \"" . escape_curl_param("SSLMate-external/$VERSION") . "\"\n";
	print $config_fh "silent\n";
	print $config_fh "include\n";
	print $config_fh "url = \"" . escape_curl_param((get_config('api_endpoint') // $API_ENDPOINT) . $command) . "\"\n";
	if ($creds) {
		print $config_fh "user = \"" . escape_curl_param(join(':', $creds->{username}, $creds->{password})) . "\"\n";
	}
	if ($method eq 'POST') {
		$post_data //= '';
		print $config_fh "data = \"" . escape_curl_param($post_data) . "\"\n";
	}
	close($config_fh);

	my ($http_status, $content_type, $response_data);
	if (!eof($response_fh)) {
		do {
			# HTTP/1.1 200 OK
			my $http_status_line = <$response_fh>;
			$http_status_line =~ s/\r?\n$//;
			(undef, $http_status, undef) = split(' ', $http_status_line);

			# Content-Type: application/json
			$content_type = undef;
			while (defined(my $line = <$response_fh>)) {
				$line =~ s/\r?\n$//;
				last if $line eq ''; # end of headers
				if ($line =~ /^Content-Type:\s*(.*)$/i) {
					$content_type = $1;
				}
			}
		} while ($http_status == 100);

		$response_data = do { local $/; <$response_fh> };
	}
	close($response_fh);
	waitpid($curl_pid, 0) or die "waitpid failed: $!";
	if ($? != 0) {
		if (WIFEXITED($?)) {
			print STDERR "Error: unable to contact SSLMate server: " . decode_curl_error(WEXITSTATUS($?)) . "\n";
		} else {
			print STDERR "Error: unable to contact SSLMate server: curl terminated with status $?\n";
		}
		return undef;
	}
	if (not $http_status) {
		print STDERR "Error: unable to contact SSLMate server: curl produced unexpected output\n";
		return undef;
	}

	return ($http_status, $content_type, \$response_data);
}

sub make_query_string {
	my ($request_data) = @_;

	my @elts;
	for my $key (keys %$request_data) {
		next unless defined $request_data->{$key};
		if (ref($request_data->{$key}) eq 'ARRAY') {
			for my $value (@{$request_data->{$key}}) {
				next unless defined $value;
				push @elts, qs_escape($key) . '=' . qs_escape($value);
			}
		} elsif (ref($request_data->{$key}) eq 'SCALAR') {
			push @elts, qs_escape($key) . '=' . qs_escape(${$request_data->{$key}});
		} else {
			push @elts, qs_escape($key) . '=' . qs_escape($request_data->{$key});
		}
	}
	$request_data = join('&', @elts);
}

sub api_call {
	my ($method, $command, $creds, $query_string, $post_data) = @_;

	$query_string = make_query_string($query_string) if ref($query_string) eq 'HASH';
	$post_data = make_query_string($post_data) if ref($post_data) eq 'HASH';

	$command .= "?$query_string" if defined($query_string) && length($query_string);

	my ($http_status, $content_type, $response_data) = $has_curl ?
				native_api_call($method, $command, $creds, $post_data) :
				external_api_call($method, $command, $creds, $post_data);

	return unless defined($http_status);

	$content_type //= '';

	if ($content_type ne 'application/json') {
		print STDERR "Error: received unexpected response from SSLMate server: response not JSON (content-type=$content_type; status=$http_status)\n";
		return;
	}
	
	my $response_obj = eval { decode_json($$response_data) };
	if (!defined($response_obj)) {
		chomp $@;
		print STDERR "Error: received malformed response from SSLMate server: $@\n";
		return;
	}
	return ($http_status, $response_obj);
}

sub default_api_credentials {
	return { username => get_config('api_key'), password => '' };
}

sub anon_api_call {
	my ($method, $command, $query_string, $post_data) = @_;
	return api_call($method, $command, undef, $query_string, $post_data);
}

sub authed_api_call {
	my ($method, $command, $query_string, $post_data) = @_;
	return api_call($method, $command, default_api_credentials, $query_string, $post_data);
}

sub openssl_genrsa {
	my ($key_file, $nbits) = @_;

	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $key_file) or die "Error: dup failed: $!";
		open(STDERR, '>', '/dev/null');
		exec('openssl', 'genrsa', $nbits);
		die "Error: Unable to run 'openssl genrsa' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	waitpid($openssl_pid, 0) or die "waitpid failed: $!";
	die "Error: 'openssl genrsa' command failed.\n" unless $? == 0;
}

sub openssl_req {
	my ($key_filename, $dn) = @_;

	my $openssl_req_cnf = make_openssl_req_cnf($dn);
	pipe(my $openssl_reader, my $openssl_writer) or die "Error: pipe failed: $!";
	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $openssl_writer) or die "Error: dup failed: $!";
		close($openssl_reader);
		exec('openssl', 'req', '-new', '-key', $key_filename, '-config', $openssl_req_cnf->filename);
		die "Error: Unable to run 'openssl req' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	close($openssl_writer);

	my $csr_data = do { local $/; <$openssl_reader> };
	close($openssl_reader);

	waitpid($openssl_pid, 0) or die "Error: waitpid failed: $!";
	die "Error: 'openssl req' command failed - is $key_filename a valid key file?\n" unless $? == 0;

	return $csr_data;
}

sub extract_crt_from_file {
	my ($crt_filename, $outform) = @_;

	$outform //= 'DER';

	pipe(my $openssl_reader, my $openssl_writer) or die "Error: pipe failed: $!";
	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $openssl_writer) or die "Error: dup failed: $!";
		close($openssl_reader);
		exec('openssl', 'x509', '-in', $crt_filename, '-outform', $outform);
		die "Error: Unable to run 'openssl x509' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	close($openssl_writer);

	my $crt = do { local $/; <$openssl_reader> };
	close($openssl_reader);

	waitpid($openssl_pid, 0) or die "waitpid failed: $!";
	die "Error: 'openssl x509' command failed - is $crt_filename a valid certificate file?\n" unless $? == 0;

	return $crt;
}

sub extract_pubkey_from_key {
	my ($key_filename, $outform) = @_;

	$outform //= 'DER';

	# The pkey command is only available in OpenSSL 1.0.0 and higher. But older versions of
	# OpenSSL don't support ECC anyways, so it's OK to just use the rsa command instead.
	my $has_pkey_command = grep /^pkey$/, `openssl list-standard-commands`;
	my $pkey_command = $has_pkey_command ? 'pkey' : 'rsa';

	pipe(my $openssl_reader, my $openssl_writer) or die "Error: pipe failed: $!";
	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $openssl_writer) or die "Error: dup failed: $!";
		open(STDERR, '>', '/dev/null') if $pkey_command eq 'rsa'; # rsa command outputs spurious text to stderr
		close($openssl_reader);
		exec('openssl', $pkey_command, '-in', $key_filename, '-pubout', '-outform', $outform);
		die "Error: Unable to run 'openssl $pkey_command' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	close($openssl_writer);

	my $pubkey = do { local $/; <$openssl_reader> };
	close($openssl_reader);

	waitpid($openssl_pid, 0) or die "waitpid failed: $!";
	die "Error: 'openssl $pkey_command' command failed - is $key_filename a valid private key file?\n" unless $? == 0;

	return $pubkey;
}

sub wait_for_cert {
	my ($cn, $cert_instance_id, $accept_dummy) = @_;

	my $start_time = time;
	my $warn_after = $start_time + 180;
	my $timeout_after = $start_time + 600;
	my $warned = 0;

	while (1) {
		my $now = time;
		my $poll;
		unless ($accept_dummy) {
			if ($now < $warn_after) {
				$poll = $warn_after - $now;
			} elsif ($now < $timeout_after) {
				$poll = $timeout_after - $now;
			} else {
				$poll = 0;
			}

			$poll = 180 if $poll > 180; # upper bound of 180 seconds
		}
		
		my ($status, $response) = authed_api_call('GET', '/certs/' . qs_escape($cn) . '/instances/' . $cert_instance_id, { poll => $poll, expand => ['crt','chain'] });
		return unless defined $response; # TODO: repeat ? b/c this could be a timeout situation

		if ($status == 200) {
			return ($response->{crt}, $response->{chain}, $response->{state} eq 'active' ? 0 : 1);
		} elsif ($response->{reason} eq 'not_ready') {
			my $now = time;
			my $retry_after = $response->{retry_after} // 5;
			if ($now < $warn_after) {
				$retry_after = 1 if $retry_after < 1; # lower bound of 1 second
			} elsif ($now < $timeout_after) {
				if (not $warned) {
					print "Sorry, your certificate isn't ready yet. I'll keep waiting, but if you'd rather do this later, you can hit Ctrl+C and we'll send you an email when it's ready.\n";
					$warned = 1;
				}
				$retry_after = 10 if $retry_after < 10; # lower bound of 10 seconds
			} else {
				# Timed out
				print STDERR "Sorry, your certificate still isn't ready. We'll send you an email when it's ready.\n";
				return;
			}
			sleep($retry_after);
		} else {
			print STDERR "Error: " . $response->{message} . "\n";
			return;
		}
	}
}

sub format_money {
	my ($amount) = @_;
	return sprintf("%.2f", $amount / 100);
}

sub prompt_for_approver_email {
	my ($approver_emails) = @_;

	my $num_emails = int(@$approver_emails);

	my $i = 1;
	for my $email (@$approver_emails) {
		print "$i. $email\n";
		$i++;
	}

	my $mesg = "Enter 1-$num_emails (or q to quit): ";

	while (1) {
		my $answer = prompt_user($mesg);
		if ($answer eq 'q') {
			return undef;
		} elsif ($answer =~ /^\d+$/ and $answer >= 1 and $answer <= $num_emails) {
			return $approver_emails->[$answer - 1];
		} else {
			print "That is not a number between 1 and $num_emails.\n";
		}
	}
}

sub prompt_for_order_confirmation {
	my ($product_info, %other_info) = @_;

	print "\n";
	print "============ Order summary ============\n";
	my @sans = grep { $_ ne $product_info->{cn} } @{$product_info->{default_sans}};
	if (@sans) {
		print "     Hostnames: ";
	} else {
		print "      Hostname: ";
	}
	print $product_info->{cn} . "\n";
	for my $san (@sans) {
		print "                " . $san . "\n";
	}
	my $desc;
	if (length $product_info->{description}) {
		$desc = $product_info->{description};
	} elsif (defined $product_info->{years}) {
		$desc = ($product_info->{is_wildcard} ? "Wildcard SSL" : "Standard SSL");
	} else {
		$desc = "1 Year " . ($product_info->{is_wildcard} ? "Wildcard SSL" : "Standard SSL");
	}
	if (defined $product_info->{years}) {
		print "       Product: $desc\n";
		print "         Price: " . format_money($product_info->{price}->{base_price}) . " / year\n";
		print "         Years: " . $product_info->{years} . "\n";
	} else {
		print "       Product: $desc\n";
		print "         Price: " . format_money($product_info->{price}->{base_price}) . "\n";
	}
	if (defined $other_info{auto_renew}) {
		print "    Auto-Renew: " . ($other_info{auto_renew} ? "Yes" : "No") . "\n";
	}
	if (defined $other_info{approver_email}) {
		print "Approver Email: " . $other_info{approver_email} . "\n";
	}
	print "\n";
	print "=========== Payment details ===========\n";
	if ($product_info->{price}->{amount_due}) {
		print "Payment Method: ";
		if ($product_info->{payment}->{method} eq 'credit_card') {
			my $card = $product_info->{payment}->{credit_card};
			print $card->{type} . " ending in " . $card->{last4};
		} elsif ($product_info->{payment}->{method} eq 'balance') {
			print "Account Balance";
		} else {
			print "Other";
		}
		print "\n";
	}
	if ($product_info->{price}->{discount}) {
		print "      Discount: " . format_money($product_info->{price}->{discount}) . " (USD)\n";
	}
	print "    Amount Due: " . format_money($product_info->{price}->{amount_due}) . " (USD)\n";
	print "\n";

	while (1) {
		my $answer = prompt_user('Press ENTER to confirm order (or q to quit): ');
		if ($answer eq '') {
			return 1;
		} elsif ($answer eq 'q') {
			return 0;
		}
	}
}

sub get_product_info {
	my ($type, $cn, %other_info) = @_;

	my ($status, $response) = authed_api_call('GET', '/products/' . qs_escape($type), { cn => $cn, %other_info });
	return undef unless defined $response;

	if ($status != 200) {
		print STDERR "Error: " . $response->{message} . "\n";
		return undef;
	}
	return $response;
}

sub do_link {
	my ($persistent) = @_;

	print "If you don't have an account yet, visit https://sslmate.com/signup\n";
	my $username = prompt_user("Enter your SSLMate username: ");
	my $password = prompt_password("Enter your SSLMate password: ");
	return 0 if not defined $password;
	if ($persistent) {
		print "Linking account... ";
	} else {
		print "Authenticating... ";
	}
	STDOUT->flush;

	my ($status, $response) = api_call('GET', '/api_credentials', { username => $username, password => $password });
	return 0 if not defined $response;

	if ($status == 200) {
		if ($persistent) {
			$personal_config{api_key} = $response->{api_key};
			save_config;
		} else {
			$ephemeral_config{api_key} = $response->{api_key};
		}
		print "Done.\n";
		unless ($persistent) {
			print "Tip: if you don't want to have to type your password every time, you can run 'sslmate link' to link this system with your account.\n\n";
		}
		return 1;
	} else {
		print STDERR "Error: " . $response->{message} . "\n";
		return 0;
	}
}

sub command_link {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate link\n";
		return 0;
	} elsif (@args > 0) {
		print STDERR "Error: sslmate link takes no arguments.\n";
		print STDERR "Usage: sslmate link\n";
		return 2;
	}

	load_config;

	print "Note: sslmate has already been linked with an account.\nContinue to link it with a different account, or press Ctrl+C to exit.\n" if is_linked;

	do_link(1) or return 1;

	return 0;
}

sub do_wait_for_cert {
	my ($cn, $cert_instance, $no_wait, $accept_dummy, $files, $new_key_filename) = @_;

	print "You will soon receive an email at " . $cert_instance->{approver_email} . " from " . $cert_instance->{approval_email_from} . ". Follow the instructions in the email to verify your ownership of your domain.\n\n";

	if ($no_wait) {
		print "Once you've verified ownership, you will be able to download your certificate with the 'sslmate download' command.\n";
		return 0;
	} elsif ($accept_dummy) {
		print "Once you've verified ownership, you will be able to download your certificate with the 'sslmate download' command.  In the meantime, you can configure your server with the temporary certificate, but this certificate will NOT be trusted by clients.\n";
	} else {
		print "Once you've verified ownership, your certificate will be automatically downloaded.  If you'd rather do this later, press Ctrl+C and download your certificate with the 'sslmate download' command instead.\n\n";
	}

	print "Waiting for ownership confirmation...\n" unless $accept_dummy;

	my ($crt, $chain_crt, $is_dummy) = wait_for_cert($cn, $cert_instance->{id}, $accept_dummy) or exit 1;
	$chain_crt //= '';

	write_cert_files($files, $new_key_filename, $crt, $chain_crt);

	print "\n";

	my $extra_info = '';
	if ($is_dummy) {
		print "A temporary, self-signed, certificate has been downloaded.\n\n";
		$extra_info = " (temporary)";
	} else {
		print "Your certificate is ready for use!\n\n";
	}

	print "           Private key file: " . $files->{key_filename} . "\n" if defined $new_key_filename;
	print "           Certificate file: " . $files->{crt_filename} . "$extra_info\n";
	print "     Certificate chain file: " . $files->{chain_crt_filename} . "$extra_info\n";
	print "Certificate with chain file: " . $files->{chained_crt_filename} . "$extra_info\n";
	#print "\n";
	#print "(" . $files->{chained_crt_filename} . " is the concatenation of " . $files->{crt_filename} . " and " . $files->{chain_crt_filename} . "; consult your program's documentation to determine whether you specify the certificate and chain in separate files or in one file.)\n";
	print "\n";
	print "Tip: generate configuration for this cert with the 'sslmate mkconfig' command.\n";
	print "Tip: test this cert's installation by running 'sslmate test $cn'.\n";
}

sub do_buy {
	my ($cn, $years, $force, $no_wait, $accept_dummy, $auto_renew, $batch, $approver_email, %opts) = @_;

	# Future TODO: support reusing key file if one already exists

	#
	# 0. Make sure files don't already exist
	#
	my $files = get_cert_paths($cn);
	check_for_existing_files(@{$files}{qw{key_filename crt_filename chain_crt_filename chained_crt_filename}}) unless $force;

	#
	# 1. Retrieve the current cert object from the server
	#
	my ($status, $cert);
	($status, $cert) = authed_api_call('GET', '/certs/' . qs_escape($cn), { expand => ['latest'] }) or exit 1;
	if ($status != 200) {
		print STDERR "Error: " . $cert->{message} . "\n";
		exit 1;
	}

	my $authorized_charge;
	my $authorized_charge_currency;

	unless ($batch) {
		#
		# Get product/pricing info from the server, ask user for confirmation
		#

		my $product_info = get_product_info('dv', $cn, years => $years, coupon_code => $opts{coupon_code}) or exit 1;
		if ($product_info->{price}->{currency} ne "USD") {
			print STDERR "Error: this version of the sslmate command does not support non-USD currencies. Please download a new version as per the instructions at https://sslmate.com.\n";
			exit 1;
		}

		if (defined $approver_email) {
			if (!grep { $_ eq $approver_email } @{$product_info->{approver_emails}}) {
				print STDERR "Error: $approver_email: not an acceptable approver email for $cn\n";
				exit 1;
			}
		} else {
			print "We need to send you an email to verify that you own this domain.\n";
			print "Where should we send this email?\n";
			print "\n";
			$approver_email = prompt_for_approver_email($product_info->{approver_emails}) or exit 1;
		}

		prompt_for_order_confirmation($product_info,
					      approver_email => $approver_email,
					      auto_renew => $auto_renew // $cert->{auto_renew}) or exit 1;

		$authorized_charge_currency = $product_info->{price}->{currency};
		$authorized_charge = $product_info->{price}->{amount_due};
	}

	#
	# 2. Generate key/CSR
	#
	$files->{key_file} = open_key_file($files->{key_filename}, $force);

	my $exit_with_error = sub {
		unlink($files->{key_filename});
		exit 1;
	};

	print "Generating private key... "; STDOUT->flush;
	truncate($files->{key_file}, 0);
	openssl_genrsa($files->{key_file}, 2048);
	close($files->{key_file});
	print "Done.\n";

	print "Generating CSR... "; STDOUT->flush;
	my $csr = openssl_req($files->{key_filename}, $cert->{dn});
	print "Done.\n";

	#
	# 3. Create/update the cert object on the server
	#
	my $request = {	auto_renew	=> $auto_renew,
			approver_email	=> $approver_email,
			csr		=> $csr };

	print "Placing order...\n";
	($status, $cert) = authed_api_call('POST', '/certs/' . qs_escape($cn), undef, $request) or $exit_with_error->();
	if ($status != 200) {
		print STDERR "Error: " . $cert->{message} . "\n";
		$exit_with_error->();
	}

	#
	# 4. Buy the certificate from SSLMate
	#
	$request = { years			=> $years,
		     authorized_charge		=> $authorized_charge,
		     authorized_charge_currency	=> $authorized_charge_currency,
		     %opts };

	my $cert_instance;
	($status, $cert_instance) = authed_api_call('POST', '/certs/' . qs_escape($cn) . '/buy', undef, $request) or $exit_with_error->();
	if ($status != 200 && $cert_instance->{reason} eq 'daily_buy_limit_exceeded') {
		print STDERR "Error: this purchase would exceed your daily spending limit.\n";
		print STDERR "To change your limit, visit https://sslmate.com/account\n";
		$exit_with_error->() if $batch;
		my $password = prompt_password("Enter your SSLMate password to approve this purchase: ");
		my ($account_id, undef) = split('_', get_config('api_key'));
		($status, $cert_instance) = api_call('POST', '/certs/' . qs_escape($cn) . '/buy', { username => $account_id, password => $password }, undef, $request) or $exit_with_error->();
	}

	if ($status != 200) {
		if ($cert_instance->{reason} eq 'price_not_authorized') {
			print STDERR "Error: the price of this certificate has changed. Please run 'sslmate buy' again.\n";
		} else {
			print STDERR "Error: " . $cert_instance->{message} . "\n";
		}
		$exit_with_error->();
	}

	print "Order complete.\n\n";
	return do_wait_for_cert($cn, $cert_instance, $no_wait, $accept_dummy, $files, $files->{key_filename});
}

sub command_buy {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate buy [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate buy www.example.com\n";
		print "         sslmate buy '*.example.com'\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force          overwrite existing files\n";
		print " --auto-renew         automatically renew this certificate before it expires\n";
		print " --no-auto-renew      don't automatically renew this certificate\n";
		print " --batch              don't prompt for confirmation\n";
		print " --email=ADDRESS      use the given approver email address\n";
		print " --no-wait            return immediately; don't wait for cert to be issued\n";
		print " --temp               return immediately with a temporary certificate\n";
		print " --coupon=CODE        use the given coupon code for a discount\n";
		print " --invoice-note=NOTE  include the given note with the invoice\n";
		print " --email-invoice-to=ADDRESS\n";
		print "                      email an invoice to the given address\n";
		return 0;
	}

	my %opts;
	my $auto_renew = undef;
	my $force = 0;
	my $batch = 0;
	my $approver_email = undef;
	my $no_wait = 0;
	my $accept_dummy = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			$force = 1;
			shift @args;
		} elsif ($args[0] eq "--auto-renew") {
			$auto_renew = 1;
			shift @args;
		} elsif ($args[0] eq "--no-auto-renew") {
			$auto_renew = 0;
			shift @args;
		} elsif ($args[0] =~ /^--coupon=(.*)$/) {
			$opts{coupon_code} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--email-invoice-to=(.*)$/) {
			$opts{email_invoice_to} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--invoice-note=(.*)$/) {
			$opts{invoice_note} = $1;
			shift @args;
		} elsif ($args[0] eq "--batch") {
			$batch = 1;
			shift @args;
		} elsif ($args[0] =~ /^--email=(.*)$/) {
			$approver_email = $1;
			shift @args;
		} elsif ($args[0] eq "--no-wait") {
			$no_wait = 1;
			shift @args;
		} elsif ($args[0] eq "--temp") {
			$accept_dummy = 1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1 && @args != 2) {
		print STDERR "Error: you must specify the hostname for the certificate.\n";
		print STDERR "Example: sslmate buy www.example.com\n";
		print STDERR "     or: sslmate buy '*.example.com'\n";
		print STDERR "See 'sslmate help buy' for help.\n";
		return 2;
	}
	if ($no_wait && $accept_dummy) {
		print STDERR "Error: --no-wait and --temp are mutually exclusive.\n";
		return 2;
	}
	if ($batch && not defined($approver_email)) {
		print STDERR "Error: in batch mode, you must specify the approver email with --email.\n";
		print STDERR "See 'sslmate help buy' for help.\n";
		return 2;
	}

	my $cn = lc $args[0];
	my $years = undef;

	if (@args == 2) {
		$years = $args[1];

		if (!Scalar::Util::looks_like_number($years) || $years < 1 || $years > 5) {
			print STDERR "Error: number of years must be between 1 and 5, inclusive.\n";
			return 1;
		}
	}

	load_config;
	if (!is_linked) {
		if ($batch || not(-t STDIN)) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;
	do_buy($cn, $years, $force, $no_wait, $accept_dummy, $auto_renew, $batch, $approver_email, %opts);
	return 0;
}

sub command_reissue {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate reissue [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate reissue www.example.com\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force        overwrite existing files\n";
		print " --no-wait          return immediately; don't wait for new cert to be issued\n";
		return 0;
	}

	my $force = 0;
	my $no_wait = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq '--force') {
			$force = 1;
			shift @args;
		} elsif ($args[0] eq "--no-wait") {
			$no_wait = 1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1) {
		print STDERR "Error: you must specify the hostname of the certificate to reissue.\n";
		print STDERR "Example: sslmate reissue www.example.com\n";
		return 2;
	}

	my $cn = lc $args[0];

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	# 1. Retrieve the current cert object from the server
	my ($cert_status, $cert) = authed_api_call('GET', '/certs/' . qs_escape($cn), { 'expand' => [ 'latest' ] }) or return 1;
	if ($cert_status != 200) {
		print STDERR "Error: " . $cert->{message} . "\n";
		return 1;
	}

	if (not $cert->{exists}) {
		print STDERR "Error: $cn: there is no certificate in your account with this common name.\n";
		return 1;
	}
	if (not defined $cert->{latest} or $cert->{latest}->{state} ne 'active') {
		print STDERR "Error: this certificate is not active.  Only active (non-expired, non-pending) certs may be reissued.\n";
		return 1;
	}
	if ($cert->{latest}->{source} eq 'import') {
		print STDERR "Error: this certificate was not purchased from SSLMate.  To reissue this cert, please see the vendor where you purchased it.\n";
		return 1;
	}

	# 2. Open the files
	my $files = get_cert_paths($cn);
	my $new_key_filename = $files->{key_filename} . ".new";

	check_for_existing_files($new_key_filename) unless $force;
	$files->{key_file} = open_key_file($new_key_filename, $force);

	my $exit_with_error = sub {
		unlink($new_key_filename);
		exit 1;
	};

	# 3. Generate new RSA key and CSR
	print "Generating private key... "; STDOUT->flush;
	truncate($files->{key_file}, 0);
	openssl_genrsa($files->{key_file}, 2048);
	close($files->{key_file});
	print "Done.\n";

	print "Generating CSR... "; STDOUT->flush;
	my $csr = openssl_req($new_key_filename, $cert->{dn});
	print "Done.\n";

	# 4. Update the CSR server-side
	print "Reissuing cert...\n";
	($cert_status, $cert) = authed_api_call('POST', '/certs/' . qs_escape($cn), undef, { csr => $csr }) or $exit_with_error->();
	if ($cert_status != 200) {
		print STDERR "Error: " . $cert->{message} . "\n";
		$exit_with_error->();
	}

	# 5. Reissue the certificate
	my ($reissue_status, $cert_instance) = authed_api_call('POST', '/certs/' . qs_escape($cn) . '/reissue') or $exit_with_error->();
	if ($reissue_status != 200) {
		print STDERR "Error: " . $cert_instance->{message} . "\n";
		$exit_with_error->();
	}

	print "Reissue complete.\n\n";
	return do_wait_for_cert($cn, $cert_instance, $no_wait, 0, $files, $new_key_filename);
}

sub command_revoke {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate revoke [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate revoke www.example.com\n";
		print "\n";
		print "Valid options:\n";
		print " -a, --all    revoke ALL certificates, even the most recent\n";
		print " --batch      don't prompt for confirmation if --all is used\n";
		print "\n";
		print "Note: By default, 'sslmate revoke' revokes all but the most recent certificate.\n";
		print "      To revoke even the most recent certificate, use the --all option.\n";
		print "\n";
		print "Tip: To replace a compromised key, first reissue the cert with 'sslmate reissue'\n";
		print "     and then revoke the old cert(s) with 'sslmate revoke' WITHOUT --all.\n";
		return 0;
	}

	my $all = 0;
	my $batch = 0;

	local @ARGV = @args;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));
	$getopt->getoptions('all|a', \$all,
			    'batch', \$batch) or return 2;

	if (@ARGV != 1) {
		print STDERR "Error: you must specify the hostname of the certificate to revoke.\n";
		print STDERR "Example: sslmate revoke www.example.com\n";
		return 2;
	}

	my $cn = lc $ARGV[0];

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	if ($all && !$batch) {
		print "WARNING: ALL instances of this certificate will be revoked, even the most\n";
		print "recent one.  You will not be able to use or reissue this certificate unless\n";
		print "you purchase it again.\n\n";
		if (-t STDIN) {
			print "Do you understand and want to continue?\n\n";
			exit 1 unless prompt_yesno();
		} else {
			print "Error: will not continue unless --batch option is specified.\n";
			exit 1;
		}
	}

	print "Revoking cert...\n";

	my ($status, $response) = authed_api_call('POST', '/certs/'.qs_escape($cn).'/revoke', undef, { all => $all }) or return 1;

	if ($status != 200) {
		print STDERR "Error: " . $response->{message} . "\n";
		return 1;
	}

	if ($response->{num_revoked} == 0 && $response->{num_active} == 0) {
		print STDERR "Error: your account contains no active certificates for '$cn'.\n";
		return 1;
	} elsif ($response->{num_revoked} == 0) {
		print STDERR "Error: the certificate for '$cn' is still in use.\n";
		print STDERR "Before revoking this certificate, please reissue it by running 'sslmate reissue $cn'.  Alternatively, if you want to revoke this certificate even though it's still in use, pass the -a option to 'sslmate revoke'.\n";
		return 1;
	} else {
		print "Successfully revoked the certificate for $cn.\n";
		print "Please allow up to two business days for this revocation to be processed. You will receive an email when this revocation is complete.\n";
		return 0;
	}
}

sub command_renew {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate renew [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate renew www.example.com\n";
		print "         sslmate renew '*.example.com'\n";
		print "\n";
		print "Valid options:\n";
		print " --batch              don't prompt for confirmation\n";
		print " --no-wait            return immediately; don't wait for new cert to be issued\n";
		print " --coupon=CODE        use the given coupon code for a discount\n";
		print " --invoice-note=NOTE  include the given note with the invoice\n";
		print " --email-invoice-to=ADDRESS\n";
		print "                      email an invoice to the given address\n";
		return 0;
	}

	my %opts;
	my $batch = 0;
	my $no_wait = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			# Ignored for backwards compatibility with pre-0.5.0
			shift @args;
		} elsif ($args[0] =~ /^--coupon=(.*)$/) {
			$opts{coupon_code} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--email-invoice-to=(.*)$/) {
			$opts{email_invoice_to} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--invoice-note=(.*)$/) {
			$opts{invoice_note} = $1;
			shift @args;
		} elsif ($args[0] eq "--batch") {
			$batch = 1;
			shift @args;
		} elsif ($args[0] eq "--no-wait") {
			$no_wait = 1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1 && @args != 2) {
		print STDERR "Error: you must specify the hostname for the certificate.\n";
		print STDERR "Example: sslmate renew www.example.com\n";
		print STDERR "     or: sslmate renew '*.example.com'\n";
		print STDERR "See 'sslmate help renew' for help.\n";
		return 2;
	}

	my $cn = $args[0];
	my $years = undef;
	if (@args == 2) {
		$years = $args[1];
		if (!Scalar::Util::looks_like_number($years) || $years < 1 || $years > 5) {
			print STDERR "Error: number of years must be between 1 and 5, inclusive.\n";
			return 1;
		}
	}

	load_config;
	if (!is_linked) {
		if ($batch || not(-t STDIN)) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	my $files = get_cert_paths($cn);
	my $pubkey_hash = undef;
	if (-f $files->{key_filename} && -r $files->{key_filename}) {
		$pubkey_hash = sha256_hex(extract_pubkey_from_key($files->{key_filename}));
	}

	
	# Retrieve the current cert object from the server
	my ($status, $cert);
	($status, $cert) = authed_api_call('GET', '/certs/' . qs_escape($cn), { expand => ['latest'] }) or exit 1;
	if ($status != 200) {
		print STDERR "Error: " . $cert->{message} . "\n";
		exit 1;
	}
	if (not $cert->{exists}) {
		print STDERR "Error: $cn: there is no certificate in your account with this common name.\n";
		return 1;
	}
	# TODO TODO: check to make sure cert is active, expiring soon, etc. ?

	my $authorized_charge;
	my $authorized_charge_currency;

	unless ($batch) {
		# Get product/pricing info from the server, ask user for confirmation

		my $product_info = get_product_info($cert->{type}, $cn, years => $years, coupon_code => $opts{coupon_code}) or exit 1;
		if ($product_info->{price}->{currency} ne "USD") {
			print STDERR "Error: this version of the sslmate command does not support non-USD currencies. Please download a new version as per the instructions at https://sslmate.com.\n";
			exit 1;
		}

		prompt_for_order_confirmation($product_info,
					      approver_email => $cert->{approver_email},
					      auto_renew => $cert->{auto_renew}) or exit 1;

		$authorized_charge_currency = $product_info->{price}->{currency};
		$authorized_charge = $product_info->{price}->{amount_due};
	}

	if (defined $pubkey_hash && $cert->{pubkey_hash} ne $pubkey_hash) {
		# The locally-installed key is out of sync with the key registered with the server.
		# So, generate a CSR from the locally-installed key and register it with the server.
		print "Generating CSR... "; STDOUT->flush;
		my $csr = openssl_req($files->{key_filename}, $cert->{dn});
		print "Done.\n";

		($status, $cert) = authed_api_call('POST', '/certs/' . qs_escape($cn), undef, { csr => \$csr }) or exit 1;
		if ($status != 200) {
			print STDERR "Error: " . $cert->{message} . "\n";
			exit 1;
		}
	}

	# Renew the certificate
	print "Placing order...\n";
	my $request = { years				=> $years,
			authorized_charge		=> $authorized_charge,
			authorized_charge_currency	=> $authorized_charge_currency,
			%opts };

	my $cert_instance;
	($status, $cert_instance) = authed_api_call('POST', '/certs/' . qs_escape($cn) . '/buy', undef, $request) or exit 1;
	if ($status != 200) {
		if ($cert_instance->{reason} eq 'price_not_authorized') {
			print STDERR "Error: the price of this certificate has changed. Please run 'sslmate renew' again.\n";
		} else {
			print STDERR "Error: " . $cert_instance->{message} . "\n";
		}
		exit 1;
	}

	print "Renewal complete.\n\n";
	return do_wait_for_cert($cn, $cert_instance, $no_wait, 0, $files);
}

sub command_req {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate req [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate req www.example.com\n";
		print "         sslmate req '*.example.com'\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force        overwrite existing files\n";
		print " --country=CODE     set country code for request\n";
		return 0;
	}

	my $country_code = 'US';
	my $force = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			$force = 1;
			shift @args;
		} elsif ($args[0] =~ /^--country=(.*)$/) {
			$country_code = $1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1) {
		print STDERR "Error: you must specify the hostname for the certificate.\n";
		print STDERR "Example: sslmate req www.example.com\n";
		print STDERR "     or: sslmate req '*.example.com'\n";
		print STDERR "See 'sslmate help req' for help.\n";
		return 2;
	}

	my $cn = lc $args[0];

	# 0. Open the files
	my $open_flags = O_WRONLY | O_CREAT | O_TRUNC;
	$open_flags |= O_EXCL unless $force;
	my $key_file;
	if (!sysopen($key_file, "$cn.key", $open_flags, 0600)) {
		print STDERR "Error: unable to open '$cn.key' for writing: $!\n";
		return 1;
	}
	my $csr_file;
	if (!sysopen($csr_file, "$cn.csr", $open_flags, 0666)) {
		print STDERR "Error: unable to open '$cn.csr' for writing: $!\n";
		return 1;
	}

	# 1. Generate an RSA key
	print "Generating private key... "; STDOUT->flush;
	openssl_genrsa($key_file, 2048);
	close($key_file);
	print "$cn.key\n";

	# 2. Generate the CSR
	print "Generating CSR... "; STDOUT->flush;
	print $csr_file openssl_req("$cn.key", { CN => $cn, C => $country_code, ST => 'Some-State', O => 'Internet Widgits Pty Ltd' });
	close($csr_file);
	print "$cn.csr\n";

	return 0;
}

sub command_download {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate download [OPTIONS] HOSTNAME ...\n";
		print "Example: sslmate download www.example.com\n";
		print "         sslmate download --all\n";
		print "\n";
		print "Valid options:\n";
		print " -a, --all    download certificate for every key in the SSLMate keys directory\n";
		print " --temp       download a temporary certificate if real certificate is not ready\n";
		return 0;
	}

	my $all = 0;
	my $accept_dummy = 0;
	while (@args >= 1) {
		if ($args[0] eq "-a" || $args[0] eq "--all") {
			$all = 1;
			shift @args;
		} elsif ($args[0] eq "--temp") {
			$accept_dummy = 1;
			shift @args;
		} else {
			last;
		}
	}

	if ((!$all && @args == 0) || ($all && @args > 0)) {
		print STDERR "Error: you must specify hostname(s) of certificate(s) to download OR use --all.\n";
		print STDERR "Example: sslmate download www.example.com\n";
		print STDERR "     or: sslmate download --all\n";
		return 2;
	}

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	if ($all) {
		# scan the key directory, populate @args for every .key file
		my $key_directory = get_config('key_directory') // '.';
		opendir(my $dh, $key_directory) or die "Error: unable to read key directory: $key_directory: $!\n";
		push @args, map { s/\.key$//; $_ } grep { /\.key$/ } readdir($dh);
		closedir($dh);

		if (@args == 0) {
			print "No certificates to download.\n" unless $quiet;
			return 10;
		}
	}

	my @certs;
	my $errors = 0;
	for my $cn (@args) {
		my $paths = get_cert_paths($cn);

		my $pubkey_hash;
		if (-f $paths->{key_filename} && -r $paths->{key_filename}) {
			$pubkey_hash = sha256_hex(extract_pubkey_from_key($paths->{key_filename}));
		}

		my $has_new_key = 0;
		my ($status, $response);
		if (-f $paths->{key_filename} . ".new" && -r $paths->{key_filename} . ".new") {
			# First try to download the cert corresponding to the new key.
			my $new_pubkey_hash = sha256_hex(extract_pubkey_from_key($paths->{key_filename} . ".new"));

			($status, $response) = authed_api_call('GET', '/certs/'.qs_escape($cn).'/instances/latest',
								{ poll => 0,
								  expand => ['crt', 'chain'],
								  pubkey_hash => $new_pubkey_hash }) or return 1;
			$has_new_key = 1 if $status == 200 && $response->{state} eq 'active';
		}
		unless ($has_new_key) {
			($status, $response) = authed_api_call('GET', '/certs/'.qs_escape($cn).'/instances/latest',
								{ expand => ['crt', 'chain'],
								  pubkey_hash => $pubkey_hash }) or return 1;
		}
		if ($status != 200) {
			if ($response->{reason} eq 'no_such_cert') {
				print STDERR "Error: $cn: There is no certificate in your account with this name.\n";
				++$errors;
				next;
			} elsif ($response->{reason} eq 'no_such_pubkey_hash') {
				print STDERR "Error: $cn: There is no certificate in your account that matches the private key " . $paths->{key_filename} . "\n";
				++$errors;
				next;
			} else {
				print STDERR "Error: $cn: " . $response->{message} . "\n";
				return 1;
			}
		}

		if ($response->{state} ne 'active' && $response->{state} ne 'pending') {
			print STDERR "Error: $cn" . ($pubkey_hash ? " (with private key " . $paths->{key_filename} . ")" : "") . ": is " . $response->{state} . "\n";
			++$errors;
			next;
		}

		$response->{chain} //= '';

		if (not($has_new_key) &&
				file_contents_are($paths->{crt_filename}, $response->{crt}) &&
				file_contents_are($paths->{chain_crt_filename}, $response->{chain}) &&
				file_contents_are($paths->{chained_crt_filename}, $response->{crt} . $response->{chain})) {

			# Certs did not change
			next;
		}

		if ($response->{state} ne 'active' && (!$accept_dummy || $response->{crt} eq '')) {
			print STDERR "Error: The certificates for $cn" . ($pubkey_hash ? " (with private key " . $paths->{key_filename} . ")" : "") . " have not yet been issued. Please try again later.\n";
			++$errors;
			next;
		}

		push @certs, { cn => $cn, paths => $paths, response => $response, has_new_key => $has_new_key };
	}

	if (@certs == 0) {
		return 1 if $errors;
		print "All certificate files already downloaded and up-to-date.\n" unless $quiet;
		return 10;
	}

	for my $cert (@certs) {
		my $cn		= $cert->{cn};
		my $paths	= $cert->{paths};
		my $response	= $cert->{response};
		my $has_new_key	= $cert->{has_new_key};

		write_cert_files($paths,
		                 $has_new_key ? $paths->{key_filename} . ".new" : undef,
		                 $response->{crt},
		                 $response->{chain});

		my $extra_info = '';
		if ($response->{state} ne 'active') {
			print "A temporary, self-signed, certificate for $cn has been downloaded.\n\n";
			$extra_info = " (temporary)";
		} else {
			print "The certificate for $cn has been downloaded.\n\n";
		}
		print "           Private key file: " . $paths->{key_filename} . "\n" if -f $paths->{key_filename};
		print "           Certificate file: " . $paths->{crt_filename} . "$extra_info\n";
		print "     Certificate chain file: " . $paths->{chain_crt_filename} . "$extra_info\n";
		print "Certificate with chain file: " . $paths->{chained_crt_filename} . "$extra_info\n";
		print "\n";
	}
	if ($errors) {
		print "Some new certificates were downloaded, but other certificates had errors. See above.\n";
	}
	return 0;
}

sub print_row {
	my ($data, $widths) = @_;

	for my $i (0..@$data-1) {
		print "  " if $i > 0;
		printf "%*s", -$widths->[$i], ($data->[$i] // '-');
	}
	print "\n";
}

sub make_cert_info {
	local *format_hash = sub {
		my ($raw_hash) = @_;
		return undef unless defined($raw_hash);
		$raw_hash =~ s/([0-9a-zA-z][0-9a-zA-Z])/:\U$1\E/g;
		return substr($raw_hash, 1);
	};
	local *format_status = sub {
		my ($raw_status) = @_;
		return 'Active' if $raw_status eq 'active';
		return 'Expired' if $raw_status eq 'expired';
		return 'Revoked' if $raw_status eq 'revoked';
		return 'Pending' if $raw_status eq 'pending';
		return 'Canceled' if $raw_status eq 'canceled';
		return $raw_status;
	};
	local *format_type = sub {
		my ($raw_type) = @_;
		return 'DV' if $raw_type eq 'dv';
		return $raw_type;
	};
	local *format_installed_status = sub {
		my ($has_local_anything, $has_local_keys, $has_local_crts) = @_;
		return "Yes" if $has_local_keys && $has_local_crts;
		return "Partially" if $has_local_anything;
		return "No";
	};
	my ($cert) = @_;

	my $local_paths = get_cert_paths($cert->{cn});
	my $has_local_anything = -e $local_paths->{key_filename} ||
				 -e $local_paths->{crt_filename} ||
				 -e $local_paths->{chain_crt_filename} ||
				 -e $local_paths->{chained_crt_filename};
	my $has_local_keys = -e $local_paths->{key_filename};
	my $has_local_crts = -e $local_paths->{crt_filename} &&
			     -e $local_paths->{chain_crt_filename} &&
			     -e $local_paths->{chained_crt_filename};
	return {
		name => $cert->{cn},
		status => format_status($cert->{latest}->{state}),
		expiration => $cert->{latest}->{expiration} ? strftime('%Y-%m-%d', localtime($cert->{latest}->{expiration})) : undef,
		has_local_anything => $has_local_anything,
		has_local_keys => $has_local_keys,
		has_local_crts => $has_local_crts,
		installed => format_installed_status($has_local_anything, $has_local_keys, $has_local_crts),
		fingerprint => format_hash($cert->{latest}->{sha1_fingerprint}),
		sha256_fingerprint => format_hash($cert->{latest}->{sha256_fingerprint}),
		auto_renew => $cert->{auto_renew} ? "Yes" : "No",
		type => format_type($cert->{latest}->{type}),
		approver_email => $cert->{approver_email},
		approval_email_from => $cert->{latest}->{approval_email_from},
	};
}

sub command_list {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate list [OPTIONS]\n";
		print "\n";
		print "Valid options:\n";
		print " --local             display only certificates that are installed locally\n";
		print " --no-local          exclude certificates that are installed locally\n";
		print " -c, --columns=COLS  include the given columns, where COLS is comma-separated\n";
		print " -z                  separate columns and terminate lines with a NUL character\n";
		print "\n";
		print "Valid columns:\n";
		print " name, status, expiration, installed, fingerprint, sha256_fingerprint,\n";
		print " auto_renew, type, approver_email, approval_email_from\n";
		return 0;
	}

	my $local;
	my $columns;
	my $machine_output;

	local @ARGV = @args;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));
	$getopt->getoptions('local!', \$local,
			    'columns|c=s', \$columns,
			    'z', \$machine_output) or return 2;

	if ($machine_output && !defined($columns)) {
		print STDERR "Error: --columns option is required if -z is used.\n";
		return 2;
	}

	my @columns = defined($columns) ? split(/,/, $columns) : qw/name status expiration installed/;
	my %column_titles = (
				name =>			'Name',
			        status =>		'Status',
			        expiration =>		'Expiration',
			        installed => 		'Installed',
			        fingerprint =>		'Fingerprint',
			        sha256_fingerprint =>	'Fingerprint (SHA-256)',
				auto_renew =>		'Auto-renew',
				type =>			'Type',
				approver_email =>	'Approver Email',
				approval_email_from =>	'Approval Email From',
			    );
	for my $column (@columns) {
		if (not exists $column_titles{$column}) {
			print STDERR "Error: Invalid column: $column\n";
			return 1;
		}
	}
	if (not @columns) {
		print STDERR "Error: no columns specified\n";
		return 1;
	}

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	my ($status, $response) = authed_api_call('GET', '/certs', { expand => ['latest'] }) or return 1;
	if ($status != 200) {
		print STDERR "Error: " . $response->{message} . "\n";
		return 1;
	}
	my @rows;
	for my $cert_obj (@{$response->{data}}) {
		my $cert_info = make_cert_info($cert_obj);
		if (defined $local) {
			next if $local && !$cert_info->{has_local_anything};
			next if !$local && $cert_info->{has_local_anything};
		}
		my @row = @{$cert_info}{@columns};
		if ($machine_output) {
			print join("\0", @row) . "\0";
		} else {
			push @rows, \@row;
		}
	}

	if (not $machine_output) {
		my @titles = @column_titles{@columns};
		my @widths;
		for my $i (0..@columns-1) {
			push @widths, max(map { length($_->[$i] // '-') } \@titles, @rows);
		}
		print_row(\@titles, \@widths);
		print '-' x (sum(@widths) + 2*(@columns-1)) . "\n";
		print_row($_, \@widths) for @rows;
	}

	return 0;
}

sub command_edit {
	local *print_our_usage = sub {
		my ($out) = @_;

		print $out "Usage: sslmate edit [OPTIONS] HOSTNAME\n";
		print $out "\n";
		print $out "Valid options:\n";
		print $out " --email=EMAIL       change the approver email of this cert\n";
		print $out " --auto-renew        enable auto-renew for this cert\n";
		print $out " --no-auto-renew     disable auto-renew for this cert\n";
	};

	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print_our_usage(*STDOUT);
		return 0;
	}

	my $auto_renew;
	my $approver_email;

	local @ARGV = @args;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));
	$getopt->getoptions('auto-renew!', \$auto_renew,
			    'email=s', \$approver_email) or return 2;
	if (@ARGV == 0) {
		print STDERR "Error: you must specify the name of the certificate to edit.\n";
		print_our_usage(*STDERR);
		return 2;
	}

	my $cn = $ARGV[0];
	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	my $request = {
		auto_renew => $auto_renew,
		approver_email => $approver_email,
	};

	my ($cert_status, $cert) = authed_api_call('POST', '/certs/' . qs_escape($cn), { expand => ['latest'] }, $request) or return 1;
	if ($cert_status != 200) {
		print STDERR "Error: " . $cert->{message} . "\n";
		return 1;
	}

	if ($cert->{latest}->{state} eq 'pending' && defined($approver_email)) {
		print "Resending approval email to $approver_email... ";
		my ($status, $response) = authed_api_call('POST',  '/certs/' . qs_escape($cn) . '/resend_approval_email', undef, {}) or return 1;
		if ($status != 200) {
			print "\n";
			print STDERR "Error resending approval email: " . $response->{message} . "\n";
			return 1;
		}
		print "Done.\n";
	}
	return 0;
}

sub command_resend_email {
	local *print_our_usage = sub {
		my ($out) = @_;

		print $out "Usage: sslmate resend-email [OPTIONS] HOSTNAME\n";
		print $out "\n";
		print $out "Valid options:\n";
		print $out " --email=EMAIL       send to the given address\n";
	};

	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print_our_usage(*STDOUT);
		return 0;
	}

	my $approver_email;

	local @ARGV = @args;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));
	$getopt->getoptions('email=s', \$approver_email) or return 2;
	if (@ARGV == 0) {
		print STDERR "Error: you must specify the name of the certificate.\n";
		print_our_usage(*STDERR);
		return 2;
	}

	my $cn = $ARGV[0];
	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	if (defined $approver_email) {
		my ($cert_status, $cert) = authed_api_call('POST', '/certs/' . qs_escape($cn), undef, { approver_email => $approver_email }) or return 1;
		if ($cert_status != 200) {
			print STDERR "Error: " . $cert->{message} . "\n";
			return 1;
		}
	}

	print "Resending approval email...\n";
	my ($status, $response) = authed_api_call('POST',  '/certs/' . qs_escape($cn) . '/resend_approval_email', undef, {}) or return 1;
	if ($status != 200) {
		print STDERR "Error: " . $response->{message} . "\n";
		return 1;
	}
	print "Approval email resent to " . $response->{approver_email} . ".\n";
	return 0;
}

sub command_test {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate test [OPTIONS] COMMONNAME\n";
		print "Example: sslmate test www.example.com\n";
		print "\n";
		print "Valid options:\n";
		print " -p, --port=NUMBER   test the given port number (default: 443)\n";
		print " -h, --host=HOSTNAME test the given host (defaults to the common name)\n";
		return 0;
	}

	my $port = 443;
	my @hostname;

	local @ARGV = @args;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));
	$getopt->getoptions('port|p=i', \$port,
			    'host|h=s', \@hostname) or return 2;

	if (@ARGV == 0) {
		print STDERR "Error: you must specify the name of the certificate to test.\n";
		print STDERR "Example: sslmate test www.example.com\n";
		return 2;
	}

	my $cn = $ARGV[0];

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	my ($status, $response) = authed_api_call('GET', '/certs/' . qs_escape($cn) . '/test',
						  { port => $port,
						    hostname => \@hostname }) or return 1;

	if ($status != 200) {
		print STDERR "Error: $cn: " . $response->{message} . "\n";
		return 1;
	}

	if (not @{$response->{result}}) {
		print STDERR "Error: could not resolve hostname.\n";
		print STDERR "To specify a hostname, use the --host option.\n" unless @hostname;
		return 1;
	}

	my $num_errors = 0;
	for my $result (@{$response->{result}}) {
		my $host = $result->{hostname} . " (" . $result->{ip_address} . ")";
		if ($result->{error}) {
			print "$host: Error: " . $result->{error} . "\n";
			++$num_errors;
		} elsif (not $result->{correct}) {
			print "$host: Incorrect certificate installed\n";
			++$num_errors;
		} elsif (not $result->{chained}) {
			print "$host: Chain certificate not installed\n";
			++$num_errors;
		} elsif ($result->{dummy}) {
			print "$host: Good (temporary, self-signed certificate)\n";
		} else {
			print "$host: Good\n";
		}
	}

	return 11 unless $num_errors == 0;
	return 0;
}

sub command_import {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate import [OPTIONS] KEYFILE CERTFILE\n";
		print "\n";
		print "Example: sslmate import www.example.com.key www.example.com.crt\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force        overwrite existing files\n";
		print " --auto-renew       automatically renew this certificate before it expires\n";
		print " --no-auto-renew    don't automatically renew this certificate\n";
		print " --no-install       don't copy the key/cert to the local key/cert directories\n";
		print " --batch            don't prompt for confirmation\n";
		print " --email=ADDRESS    use the given approver email address\n";
		return 0;
	}

	my $force = 0;
	my $auto_renew = undef;
	my $install = 1;
	my $batch = 0;
	my $approver_email = undef;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			$force = 1;
			shift @args;
		} elsif ($args[0] eq "--auto-renew") {
			$auto_renew = 1;
			shift @args;
		} elsif ($args[0] eq "--no-auto-renew") {
			$auto_renew = 0;
			shift @args;
		} elsif ($args[0] eq "--no-install") {
			$install = 0;
			shift @args;
		} elsif ($args[0] eq "--batch") {
			$batch = 1;
			shift @args;
		} elsif ($args[0] =~ /^--email=(.*)$/) {
			$approver_email = $1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 2) {
		print STDERR "Error: you must specify the key file and cert file paths.\n";
		print STDERR "Example: sslmate import www.example.com.key www.example.com.crt\n";
		return 2;
	}

	if ($batch && not defined($approver_email)) {
		print STDERR "Error: in batch mode, you must specify the approver email with --email.\n";
		print STDERR "See 'sslmate help import' for help.\n";
		return 2;
	}

	# 0. Load config, etc.
	load_config;
	if (!is_linked) {
		if ($batch || not(-t STDIN)) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	do_import($force, $auto_renew, $install, $args[0], $args[1], undef, $batch, $approver_email);
	return 0;
}

sub do_import {
	my ($force, $auto_renew, $install_locally, $source_key_path, $source_crt_path, $cn, $batch, $approver_email) = @_;

	# 1. Read the key
	open(my $source_key_file, '<', $source_key_path) or die "Error: Unable to open $source_key_path: $!\n";
	my $key = do { local $/; <$source_key_file> };
	close($source_key_file);
	my $pubkey_hash = sha256_hex(extract_pubkey_from_key($source_key_path));

	# 2. Read the crt
	-f $source_crt_path && -r $source_crt_path or die "Error: No such file: $source_crt_path\n";
	my $crt = extract_crt_from_file($source_crt_path, 'PEM');
	defined($crt) or die "Error: Unable to parse $source_crt_path - is it a valid certificate file?\n";

	# 3. Parse the crt
	# We could do this with a Perl module like Crypt::X509, but in order to keep the dependency
	# footprint small, we do this with an API call instead.
	my ($status, $crt_info) = authed_api_call('POST', '/utils/parse_crt', undef, { crt => \$crt }) or exit 1;
	if ($status != 200) {
		print STDERR "Error: $source_crt_path: " . $crt_info->{message} . "\n";
		return 1;
	}
	$cn //= $crt_info->{cn};
	if ($crt_info->{pubkey_hash} ne $pubkey_hash) {
		print STDERR "Error: The certificate ($source_crt_path)'s public key does not match the private key ($source_key_path)\n";
		exit 1;
	}

	# 4. Retrieve the current cert object from the server
	my $cert_obj;
	($status, $cert_obj) = authed_api_call('GET', '/certs/' . qs_escape($cn), { expand => ['latest'] }) or exit 1;
	if ($status != 200) {
		print STDERR "Error: " . $cert_obj->{message} . "\n";
		exit 1;
	}

	# 5. Get product info from the server, ask user to choose approver email (unless we're in batch mode)
	unless ($batch) {
		my $product_info = get_product_info('dv', $cn) or exit 1;

		my $has_nondns_sans = 0;
		my @missing_sans;
		for my $san (@{$crt_info->{sans}}) {
			if ($san->{type} ne 'dns') {
				$has_nondns_sans = 1;
			} elsif (!grep { $_ eq $san->{value} } @{$product_info->{default_sans}}) {
				push @missing_sans, $san;
			}
		}
		if ($has_nondns_sans) {
			print "WARNING: This certificate contains non-DNS subject alternative names.\n";
			print "SSLMate does not support non-DNS subject alternative names.  When this\n";
			print "certificate renews, the non-DNS subject alternative names will be dropped.\n\n";
			print "Do you understand and want to import this certificate anyways?\n\n";
			exit 1 unless prompt_yesno();
			print "\n";
		}
		if (@missing_sans) {
			print "WARNING: This certificate contains the following subject alternative names:\n\n";
			for my $san (@missing_sans) {
				print "\t$san\n";
			}
			print "\nWhen this certificate renews, these subject alternative names will be dropped.\n";
			print "Do you understand and want to import this certificate anyways?\n\n";
			exit 1 unless prompt_yesno();
			print "\n";
		}
		if (defined $approver_email) {
			if (!grep { $_ eq $approver_email } @{$product_info->{approver_emails}}) {
				print STDERR "Error: $approver_email: not an acceptable approver email for $cn\n";
				exit 1;
			}
		} else {
			print "When it's time to renew this certificate, we will need to send you an email to\n";
			print "verify that you own this domain.  Where should we send this email?\n";
			print "\n";
			$approver_email = prompt_for_approver_email($product_info->{approver_emails}) or exit 1;
		}
	}

	# 6. Generate the CSR
	my $csr = openssl_req($source_key_path, $cert_obj->{dn});

	# 7. Prepare the destination files
	my $files;
	if ($install_locally) {
		$files = get_cert_paths($cn);
		if (realpath($source_key_path) eq realpath($files->{key_filename})) {
			# Don't bother to write the key because it's already in place
			delete $files->{key_filename};
		}
		unless ($force) {
			my @check_files = qw{key_filename chain_crt_filename chained_crt_filename};
			if (realpath($source_crt_path) ne realpath($files->{crt_filename})) {
				# Only care if .crt file exists if it's not the same file we're importing
				push @check_files, 'crt_filename';
			}
			check_for_existing_files(@{$files}{@check_files});
		}

		$files->{key_file} = open_key_file($files->{key_filename}, $force) if defined $files->{key_filename};
	}

	my $exit_with_error = sub {
		unlink($files->{key_filename}) if $install_locally && defined $files->{key_filename};
		exit 1;
	};

	# 8. Create/update the cert object on the server
	my $request = {	auto_renew	=> $auto_renew,
			approver_email	=> $approver_email,
			csr		=> \$csr };

	print "Importing certificate for $cn...\n";
	($status, $cert_obj) = authed_api_call('POST', '/certs/' . qs_escape($cn), undef, $request) or $exit_with_error->();
	if ($status != 200) {
		print STDERR "Error: " . $cert_obj->{message} . "\n";
		$exit_with_error->();
	}

	# 9. Create a new cert instance with this crt file
	my $cert_instance;
	($status, $cert_instance) = authed_api_call('POST', '/certs/' . qs_escape($cn) . '/instances',
							{ expand => ['chain'] },
							{ crt => \$crt }) or $exit_with_error->();
	if ($status != 200) {
		print STDERR "Error: " . $cert_instance->{message} . "\n";
		$exit_with_error->();
	}

	# 10. Write the key, crt, and chain to the destination directory
	$cert_instance->{chain} //= '';

	if ($install_locally) {
		if (defined $files->{key_file}) {
			# write .key file
			truncate($files->{key_file}, 0);
			print {$files->{key_file}} $key;
			close $files->{key_file};
		}

		write_cert_files($files, undef, $crt, $cert_instance->{chain});
	}

	print "\n";
	print "Your certificate has been imported to SSLMate.\n\n";
	if ($install_locally) {
		print "           Private key file: " . ($files->{key_filename} // $source_key_path) . "\n";
		print "           Certificate file: " . $files->{crt_filename} . "\n";
		print "     Certificate chain file: " . $files->{chain_crt_filename} . "\n";
		print "Certificate with chain file: " . $files->{chained_crt_filename} . "\n";
	}
}

sub command_mkconfig {
	local @ARGV = @_;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));

	my $help_opt = 0;
	my $templates_opt = 0;
	my $no_security_opt = 0;
	$getopt->getoptions('templates', \$templates_opt,
			    'no-security', \$no_security_opt,
			    'help|?', \$help_opt) or return 2;

	if ($help_opt) {
		print "Usage: sslmate mkconfig [--no-security] TEMPLATE COMMONNAME\n";
		print "   or: sslmate mkconfig --templates\n";
		print "Example: sslmate mkconfig apache www.example.com\n";
		print "\n";
		print "Valid options:\n";
		print " --templates    output a list of available config templates\n";
		print " --no-security  don't include recommended security settings\n";
		return 0;
	}

	load_config;
	init_default_paths(0);

	if ($templates_opt) {
		my ($status, $response) = anon_api_call('GET', '/config_templates') or return 1;
		if ($status != 200) {
			print STDERR "Error: " . $response->{message} . "\n";
			return 1;
		}

		print join("\n", sort(map { $_->{name} } @{$response->{data}}), '');

		return 0;
	}

	if (@ARGV != 2) {
		print STDERR "Error: you must specify the template and certificate name.\n";
		print STDERR "Example: sslmate mkconfig apache www.example.com\n";
		print STDERR "Run 'sslmate help mkconfig' for help.\n";
		return 2;
	}

	my ($template_name, $common_name) = @ARGV;

	my ($status, $response) = anon_api_call('GET', '/config_templates/' . qs_escape($template_name),
						{ expand => [ 'template' ],
						  include_security_settings => $no_security_opt ? undef : 1 }) or return 1;

	if ($status != 200) {
		if ($response->{reason} // '' eq 'template_not_found') {
			print STDERR "Error: $template_name: Unknown configuration template.\n";
			print STDERR "Run 'sslmate mkconfig --templates' for a list for available templates.\n";
			return 1;
		}

		print STDERR "Error: $template_name: " . $response->{message} . "\n";
		return 1;
	}

	my $paths = get_cert_paths($common_name);
	my %vars = ('__KEY_PATH__'	=> $paths->{key_filename},
		    '__CERT_PATH__'	=> $paths->{crt_filename},
		    '__CHAIN_PATH__'	=> $paths->{chain_crt_filename},
		    '__CHAINED_PATH__'	=> $paths->{chained_crt_filename});

	my $template = $response->{template};
	for my $var (keys %vars) {
		my $value = $vars{$var};
		$template =~ s/$var/$value/g;
	}

	print $template;
	return 0;
}

sub command_help {
	my @args = @_;

	if (@args == 0 || $args[0] eq 'help') {
		print_usage(*STDOUT);
	} else {
		main($args[0], "-?");
	}
	return 0;
}

sub command_version {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate version [OPTIONS]\n";
		print "\n";
		print "Valid options:\n";
		print " --no-check         don't check for the latest version\n";
		print " --is-latest        exit non-zero if there is a newer version\n";
		return 0;
	}

	my $check = 1;
	my $is_latest = 0;
	while (@args >= 1) {
		if ($args[0] eq "--no-check") {
			$check = 0;
			shift @args;
		} elsif ($args[0] eq "--is-latest") {
			$is_latest = 1;
			shift @args;
		} else {
			last;
		}
	}
	die "Error: --no-check and --is-latest are mutually-exclusive.\n" if $is_latest && !$check;

	print "SSLMate $VERSION\n" unless $is_latest;
	if ($check) {
		load_config;
		my ($status, $response) = anon_api_call('GET', '/latest_client_version');

		if (not $response) {
			print STDERR "Error: unable to determine latest available version.\n";
			exit 1 if $is_latest;
		} elsif ($status != 200) {
			print STDERR "Error: unable to determine latest available version: " . $response->{message} . "\n";
			exit 1 if $is_latest;
		} else {
			if ($VERSION ne $response->{latest_client_version}) {
				exit 10 if $is_latest;
				print "New version of SSLMate available: " . $response->{latest_client_version} . "\n";
			}
		}
	}
	return 0;
}

sub main {
	my @args = @_;

	while (@args >= 1) {
		if ($args[0] eq "-p" && @args >= 2) {
			shift @args;
			$config_profile = $args[0];
			shift @args;
		} elsif ($args[0] =~ /^--profile=(.*)$/) {
			$config_profile = $1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args == 0) {
		print_usage(*STDERR);
		return 2;
	}

	my $command = shift @args;

	if ($command eq 'buy') {
		return command_buy @args;
	} elsif ($command eq 'reissue') {
		return command_reissue @args;
	} elsif ($command eq 'revoke') {
		return command_revoke @args;
	} elsif ($command eq 'renew') {
		return command_renew @args;
	} elsif ($command eq 'req') {
		return command_req @args;
	} elsif ($command eq 'download') {
		return command_download @args;
	} elsif ($command eq 'list') {
		return command_list @args;
	} elsif ($command eq 'edit') {
		return command_edit @args;
	} elsif ($command eq 'resend-email') {
		return command_resend_email @args;
	} elsif ($command eq 'test') {
		return command_test @args;
	} elsif ($command eq 'import') {
		return command_import @args;
	} elsif ($command eq 'link') {
		return command_link @args;
	} elsif ($command eq 'mkconfig') {
		return command_mkconfig @args;
	} elsif ($command eq 'help') {
		return command_help @args;
	} elsif ($command eq 'version') {
		return command_version @args;
	} else {
		print STDERR "sslmate: '$command' is not a valid sslmate command.  See 'sslmate help'.\n";
		return 1;
	}
}

exit main @ARGV;
